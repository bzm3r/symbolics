//! Let's enter a world that exists only in our mind.
//!
//! Every thing in our world is something we've made, so reset, and start
//! with nothing. To differentiate between things, we label them. Right now,
//! we have nothing, so we can label it, as `0`---the label is up to us, so
//! we could have called it `None`, or `Empty`, it doesn't matter. What
//! matters is that we distinguish between `0`, and not `0`.
//!
//! Not `0` is complicated. Make exactly one thing in our world. Exactly one
//! thing. How do you know what one means? Never mind, let's just keep
//! moving, and let's label the thing `1`, to differentiate it from `0`.
//!
//! Make another thing, that is exactly the same thing as `1`, in every way
//! possible. Absolutely every way possible. Can you tell it apart from `1`,
//! if it is exactly the same thing? No, clearly not, there is nothing that
//! allows you to differentiate it from `1`. Wait, did you actually make
//! "another" thing, because I asked you to? It seems that even though you
//! can't tell the things you're "making" apart, you've kept track of how
//! many things you've made, and then you're labelling (counting) how many
//! things you've made.
//!
//! You're labelling each "action", even if "unconsciously". By labelling
//! them, you are making them things in our world! This is polluting our
//! world. Stop! Unlabel everything except for `0` and `1`.
//!
//! The lesson is that you can't make another thing which is exactly the
//! same as `1`, because if you did, you'd actually be differentiating
//! the things based on memory of how many things you've previously made,
//! but we wanted to make something that is exactly like `1` in every way
//! possible...without any hope or possibility of differentiating them, even
//! if it is by keeping track of how many things you've previously made.
//!
//! Okay, this time, make another thing, that has at least one way to
//! differentiate it from 1, because we'll give it the label `2`. What a
//! weird tasting symbol. You want to sound it out as "two"? Hm, that's a
//! good idea, because I guess when we are not directly mind melding, like
//! right now, we can use the sounds as labels, instead of tastes.
//!
//! Anyway, how many things do we have now? Oh, I guess you don't know what
//! I mean when I say "how many things" do we have now? Okay, new plan. Let's
//! step out of our world, and back into the real world. Let me write down
//! `0` on a piece of paper, to represent "no breaths". Every time you
//! take a breath in, I'm going to put down another symbol, to mark it.
//! Okay, go!
//!
//! `*`....`**`...`***`...`****`...
//!
//! What, you don't like that?! Hm, I guess you do have a point, it took me
//! about as long to write out the stars as it took you to take one breath
//! in. Just breathe slower! Then I'll have time. Fine, I suppose you're
//! right. You can only breathe so slow, and eventually I won't have the
//! time to write out all the stars. Time is such a weird thing! When you
//! breathe, time passes, and when I write down symbols, time passes, and
//! we want to save time by writing as few symbols as possible. What is
//! time? Anyway, moving on. I have a great idea! Let's start again. I'll
//! put down `0` on the paper...and...go!
//!
//! `0` | `1`...`10`...`11`...`100`...`101`...`111`...`1000`...`1001`...
//!
//! Hm, it's getting too slow again? This is a good idea though, right? I
//! only had to create one new symbol, and then I kept re-arranging it
//! together with the other symbol we had, which was `0`. We can make
//! it faster! Let me show you. Okay, let me write down `0`, and...then...
//! go! Start breathing!
//!
//! `0` | `1`...`2`...`100`...`101`...`102`...`110`...`120`...`200`...`201`...
//!
//! Yeah, I'm getting bored too. Alright, but let's define "how many
//! breaths did you take since I wrote `START`" to be `201`. So, the final
//! symbol I create after I started labelling each breath of yours, is
//! the answer to "how many breaths did you take?". Similarly, the answer
//! to "how many things are there?" is the final label I write down after
//! marking each distinguishable thing we have using this pattern based
//! system for generating new labels.
//!
//! Wow, it turns out we both know the same pattern based system:
//!
//! `0` | `1`, `2`, `3`, `4`, `5`, `6`, `7, `8`, `9`, `10`, `11`, `12`...
//!
//! Let's step back into our imaginary world. We have nothing `0`. We have
//! `1`, and we have `2`. So how many things do we have? `2`. Alright,
//! let's decide that `2` comes AFTER `1`, since I would use the symbol
//! `2` to mark the breath you take AFTER the one I marked with `1`.
//! Similarly, `1` comes BEFORE `2`. There are many words similar to
//! "after" in flavour; for example: faster, bigger, heavier. Similarly,
//! there are many words similar to to "before" in flavour; for example:
//! slower, smaller, lighter. Is it just me, or is there's something
//! similar about opposite concepts, and us distinguishing between `0` and
//! `1`. Anyway, moving on. In addition to before and after, many people say
//! smaller and bigger, or less than and greater than.
//!
//! Suppose you make another object, distinguishable from `1` and `2`.
//! Just like counting breaths, I'll label it with `3`, and so on. Let
//! a bunch of things in our world that we've labelled using our special
//! system, and thus "counted", be called a sequence. The `3`rd item, or
//! the item with index `3`, is the thing with label `3` on it.
//!
//! Okay, world reset! Everything disappears. Now, let's make a mini-world
//! within our world. Call it a "theory"...Greek for "contemplation,
//! speculation, a looking at, things looked at". Oh, you just want to call
//! it a "contemplation"? But "theory" has less letters! Yay! I win!
//!
//! Okay, so let's make a theory. Let's make it empty. Well, as empty as
//! it can be. Since it exists in our main world, it must be polluted with
//! some concept of "0, 1, 2, 3...". Oh well. Anyway, let's call our
//! new world a "binary theory". Binary comes from the Latin "bīnī", which
//! means "two-by-two", or "pair”), and I want to call it this because
//! there will only be two things in our world. Oh, you want to call it
//! "pair theory"? Okay, that is less letters...fine! You win...wait!
//! What if we called it `Bin` theory? I win!
//!
//! Alright, so, let's consider `Bin` theory. First, we distinguish
//! nothing, and call it `BOT`, from ("bottom"), and then we distinguish
//! some thing that is not `BOT`, call it `TOP`. There are no other things in our
//! world. `Bin` theory, I think, is the smallest theory which is not
//! boring, but to each their own.
//!
//! Now here's a bizarre concept: every thing in our theory is a
//! "function"---from Latin functiō (“performance, execution”), in turn
//! from functus, perfect participle of fungor (“to perform, execute,
//! discharge”). I call them functions, because we will allow things
//! in our theory to interact with each other.
//!
//! Every function takes a sequence of factors as input, and this
//! sequence has count, which is called the `arity` of the factors. A
//! factors does something to its input sequence of factors to produce
//! an output sequence of factors. The length of the output sequence is
//! called the dimension of the function.
//!
//! A function's arity must be non-negative, but this means a function
//! could have arity `0`: in other words, it takes nothing as input, and
//! if a function takes nothing as input, we will guarantee
//! that it will always produce the same output. A function's dimension
//! cannot be `0`.
//!
//! We say that function `A` is connected to function `B` if `A` can be in an
//! input sequence given to `B`. A factory of factors is a bunch of factors
//! connected to each other.
//!
//! `BOT` and `TOP are `0`-ary factors. So they can't really do anything
//! to each other, or anything else. They can only be "end-results" of a
//! factory.
//!
//! Let's make our very first function. Call it `NOT`. It is `1`-ary. To
//! define `NOT`, we must define what it does for each `0`-ary function in our
//! theory. Let's define `NOT` as follows: `NOT.TOP` (`NOT` applied to `TOP`)
//! is the same as `BOT`, and `NOT.BOT` is the same as `TOP`.
//!
//! Hm, actually, maybe we should have first defined `==`, which is a
//! `2`-ary function. If `X` and `Y` are both `TOP`, then `X == Y` is `TOP`,
//! and if `X` and `Y` are both `BOT`, then `X == Y` is `TOP`. The only
//! case when `X == Y` is not `TOP` is when one of `X` or `Y` is `BOT`. All `n`-ary factors in this theory,
//! where `n > 0`, Note that it is useful to label functions, so let every function have
//! a label associated with it (we do not like anonymous functions). Let the
//! set `{TOP, BOT}` be labelled `Bin` (from "binary"). We say that a
//! `0`-ary function is of type `A`, if it belongs to the set `A`.
//!
//! Suppose we have a sequence of functions. The type of this sequence is
//! the sequence of types of each function in the sequence. The type of a
//! function is the type of its output sequence. The input type of a function
//! is the type of its input sequence. The total type of a function is the
//! type `IN_TYPE -> TYPE`, where `IN_TYPE` is the input type, and `TYPE` is the
//! type of function.
//!
//! The type of a function is the type of the sequence of symbols it returns.
//!

use crate::func::Function;
use crate::types::Type;

mod func;
mod types;
mod id;

fn sample_function() -> Function {
    let bin = Type::new_prim("Bin");
    let bin2 = Type::Sequence(vec![bin.clone(); 2]);

    let top = Function::new_const("TOP", bin.clone());
    // let bot = Function::new_const("BOT", bin.clone());
    let x = Function::new_var("x", bin.clone());
    let y = Function::new_var("y", bin.clone());
    
    let mut and = Function::new("AND", bin2, bin.clone()).with_inputs(vec![Some(x), Some(top)]);
    let mut not = Function::new("NOT", bin.clone(), bin).with_inputs(vec![Some(and)]);
    not.change_input(0, y);
}

// use crate::func::Function;
// use crate::types::Type;
//
// pub struct Transform {
//     involved: Vec<String>,
//     program: fn(Vec<Function>) -> Vec<Function>,
// }
//
// pub struct Theory {
//     name: String,
//     primitives: (Vec<Function>, Vec<Transform>),
//     additional: (Vec<Function>, Vec<Transform>),
// }

// pub enum ReturnError {
//     InvalidInputType,
//     NoMatchingDefn,
// }
//
// impl Function {
//     fn apply(&self, input: Function) -> Result<Vec<Function>, ReturnError> {
//         if self.input_ty ==  {
//             for defn in defns.iter() {
//                 match defn.apply(&input) {
//                     Some(result) => {
//                         return Ok(result);
//                     },
//                     None => continue,
//                 }
//             }
//             Err(ReturnError::NoMatchingDefn)
//         }
//         Err(ReturnError::InvalidInputType)
//     }
//
//     pub fn same_type(&self, other: &Vec<Function>) -> bool {
//
//     }
// }
//
